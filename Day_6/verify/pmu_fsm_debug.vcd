$date
	Sun Oct  5 12:41:06 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_pmu_fsm $end
$var wire 3 ! curr_state [2:0] $end
$var wire 1 " seq_busy $end
$var wire 1 # retention_save $end
$var wire 1 $ retention_restore $end
$var wire 1 % retention_en $end
$var wire 1 & reset_ctrl $end
$var wire 2 ' pwr_state [1:0] $end
$var wire 1 ( pwr_gate_en $end
$var wire 1 ) error $end
$var wire 2 * dvfs_ctrl [1:0] $end
$var wire 1 + clk_gate_en $end
$var reg 1 , clk $end
$var reg 1 - clk_stable $end
$var reg 1 . pwr_stable $end
$var reg 1 / req_idle $end
$var reg 1 0 req_off $end
$var reg 1 1 req_sleep $end
$var reg 1 2 reset_n $end
$var reg 1 3 retention_ready $end
$var reg 1 4 wake_up $end
$var integer 32 5 error_count [31:0] $end
$var integer 32 6 test_count [31:0] $end
$scope function get_state_name $end
$var reg 3 7 state [2:0] $end
$upscope $end
$scope module dut $end
$var wire 1 , clk $end
$var wire 1 - clk_stable $end
$var wire 1 . pwr_stable $end
$var wire 1 / req_idle $end
$var wire 1 0 req_off $end
$var wire 1 1 req_sleep $end
$var wire 1 2 reset_n $end
$var wire 1 3 retention_ready $end
$var wire 1 4 wake_up $end
$var wire 1 8 wake_up_sync $end
$var wire 1 9 req_sleep_sync $end
$var wire 1 : req_off_sync $end
$var wire 1 ; req_idle_sync $end
$var reg 1 + clk_gate_en $end
$var reg 3 < curr_state [2:0] $end
$var reg 2 = dvfs_ctrl [1:0] $end
$var reg 1 ) error $end
$var reg 3 > next_state [2:0] $end
$var reg 1 ( pwr_gate_en $end
$var reg 2 ? pwr_state [1:0] $end
$var reg 1 & reset_ctrl $end
$var reg 1 % retention_en $end
$var reg 1 $ retention_restore $end
$var reg 1 # retention_save $end
$var reg 1 " seq_busy $end
$var reg 8 @ seq_timer [7:0] $end
$var reg 4 A sync_stage1 [3:0] $end
$var reg 4 B sync_stage2 [3:0] $end
$upscope $end
$scope task check_state $end
$var reg 3 C expected_state [2:0] $end
$var reg 81 D state_name [80:0] $end
$upscope $end
$scope task reset_system $end
$upscope $end
$scope task test_active_to_idle_debug $end
$upscope $end
$scope task test_active_to_sleep_ent_debug $end
$upscope $end
$scope task wait_cycles $end
$var integer 32 E cycles [31:0] $end
$var integer 32 F i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx F
bx E
bx D
bx C
b0 B
b0 A
b0 @
b0 ?
b0 >
b11 =
b0 <
0;
0:
09
08
bx 7
b0 6
b0 5
04
13
02
01
00
0/
1.
1-
0,
0+
b11 *
0)
0(
b0 '
0&
0%
0$
0#
0"
b0 !
$end
#5000
1,
#10000
0,
#15000
1,
#20000
0,
#25000
1,
#30000
0,
#35000
1,
#40000
0,
#45000
12
1,
#50000
0,
#55000
1,
#60000
0,
#65000
b1000 A
b0 F
b100 E
1/
b0 7
1,
#70000
0,
#75000
b1 >
1;
b1000 B
b1 F
1,
#80000
0,
#85000
b1 !
b1 <
b10 F
1,
#90000
0,
#95000
1+
b1 '
b1 ?
b11 F
b1 7
1,
#100000
0,
#105000
b0 >
0;
b0 '
b0 ?
0+
b0 !
b0 <
b0 B
b0 A
02
b1 6
b1001001010001000100110001000101 D
b1 C
0/
b100 F
1,
#110000
0,
#115000
1,
#120000
0,
#125000
1,
#130000
0,
#135000
1,
#140000
0,
#145000
1,
#150000
0,
#155000
12
1,
#160000
0,
#165000
1,
#170000
0,
#175000
b100 A
b0 F
11
b0 7
1,
#180000
0,
#185000
b100 >
19
b100 B
b1 F
1,
#190000
0,
#195000
1"
b100 !
b100 <
b10 F
1,
#200000
0,
#205000
1"
1%
1#
b10 '
b10 ?
b1 @
b11 F
b100 7
1,
#210000
0,
#215000
1"
b0 A
b10 @
b10 '
b10 ?
1#
1%
b101 E
b10 6
b10100110100110001000101010001010101000001011111010001010100111001010100 D
b100 C
01
b0 F
1,
#220000
0,
#225000
b10 >
1"
09
b10 '
b10 ?
0#
1%
b11 @
b0 B
b1 F
1,
#230000
0,
#235000
0"
b0 @
b10 !
b10 <
b10 '
b10 ?
1%
b10 F
1,
#240000
0,
#245000
b1 *
b1 =
1(
1+
b10 '
b10 ?
1%
b11 F
b10 7
1,
#250000
0,
#255000
b10 '
b10 ?
b1 *
b1 =
1%
1(
1+
b100 F
1,
#260000
0,
#265000
b10 '
b10 ?
b1 *
b1 =
1%
1(
1+
b11 6
b101001101001100010001010100010101010000 D
b10 C
b101 F
1,
